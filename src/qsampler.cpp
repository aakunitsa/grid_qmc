#include "qsampler.h"
#include <algorithm> // upper_bound, lower_bound
#include <cassert>

void Uniform::single_replace(std::vector<size_t> &det) {
    // det will be modified in this function!!!
    auto nocc = det.size();
    bool accepted = false;
    size_t n1porb = (size_t)bas.get_n1porb();
    std::uniform_int_distribution<size_t> g_occ(0, nocc - 1), g_offset(1, n1porb - 1);
    auto to_remove = std::next(det.begin(), g_occ(g));
    size_t removed_orbital = *to_remove;
    det.erase(to_remove);
    while(!accepted) {
        size_t new_orbital = (removed_orbital + g_offset(g)) % n1porb;
        // Special case
        if (det.size() == 0) {
            det.push_back(new_orbital);
            accepted = true;
        // General case
        } else {
            auto it_up = std::lower_bound(det.begin(), det.end(), new_orbital);
            if (it_up != det.end() && *it_up == new_orbital)
                continue;
            else {
                accepted = true;
                det.insert(it_up, new_orbital); // will insert the orbital ___before___ the element it_up
            }
        }
    }
}

void Uniform::double_replace(std::vector<size_t> &det) {
    auto nocc = det.size();
    bool accepted = false;
    size_t n1porb = (size_t)bas.get_n1porb();
    std::uniform_int_distribution<size_t> g_occ(0, nocc - 1), g_offset_occ(1, nocc - 1);
    // Generate an occupied pair
    auto o1 = g_occ(g), o2 = (o1 + g_offset_occ(g)) % nocc; 
    // o1 < o2; should not be equal
    if (o1 > o2) std::swap(o1, o2);
    size_t removed_orbital1 = *std::next(det.begin(), o1), removed_orbital2 = *std::next(det.begin(), o2);
    det.erase(std::next(det.begin(), o1));
    det.erase(std::next(det.begin(), o2 - 1));
    // Setup piece-wise constant distributions to generate virtuals 
    std::vector<double> intervals1 {1.0, (double)(removed_orbital2 - removed_orbital1) - 1, (double)(removed_orbital2 - removed_orbital1) + 1, (double)n1porb };
    std::vector<double> intervals2 {1.0, (double)(n1porb - removed_orbital2 + removed_orbital1) - 1, (double)(n1porb - removed_orbital2 + removed_orbital1) + 1, (double)n1porb };
    std::vector<double> w {1., 0., 1.};
    std::piecewise_constant_distribution g_offset1(intervals1.begin(), intervals1.end(), w.begin()), 
                                         g_offset2(intervals2.begin(), intervals2.end(), w.begin());
    // Random displacements generated by piecewise_constant_distribution can never be equal to the right boundaries of the
    // intervals; in order to get size_t values we will have to do type casting
    while(!accepted) {
        size_t new_orbital1 = (removed_orbital1 + (size_t)g_offset1(g)) % n1porb,
               new_orbital2 = (removed_orbital2 + (size_t)g_offset2(g)) % n1porb;
        if (new_orbital1 == new_orbital2) 
            continue;
        else {
            if (new_orbital1 > new_orbital2) std::swap(new_orbital1, new_orbital2);
            // Check if any of the orbitals coincides with the remaining occupied;
            // if not - accpet else reject both

            // Special case
            if (det.size() == 0) {
                det.push_back(new_orbital1);
                det.push_back(new_orbital2);
                accepted = true;
            } else {
                // This does too many passes over the determinant; Will think about how to optimize it later
                if (!std::binary_search(det.begin(), det.end(), new_orbital1) && !std::binary_search(det.begin(), det.end(), new_orbital2)) {
                    accepted = true;
                    auto it_up1 = std::lower_bound(det.begin(), det.end(), new_orbital1);
                    det.insert(it_up1, new_orbital1);
                    auto it_up2 = std::lower_bound(det.begin(), det.end(), new_orbital2);
                    det.insert(it_up2, new_orbital2); 
                }
            }
        }
    }
}


std::tuple<double, std::vector<size_t> > Uniform::excitation(size_t det_id, size_t n_samples) {
    auto [na, nb] = bas.get_ab();
    auto [nas, nbs] = bas.get_num_str(); // Strings are stored as follows b0a0, b0a1, b0a2, ..., b1a0, b1a1, ...
    auto [ia, ib] = bas.unpack_str_index(det_id);
    const auto &det_a = bas.a(ia);
    const auto &det_b = (nb > 0 ? bas.b(ib) : std::vector<size_t>());
    std::uniform_real_distribution<double> u(0.0, 1.0);
    std::vector<size_t> samples_list(n_samples); // Result
    for (size_t isample = 0; isample < n_samples; isample++) {
        // Selection is driven by single/double choice
        if (u(g) < p_s) {
            // Do singles after deciding which string to use
            if (u(g) < p_a) {
                // We will be working with alpha string here
                // 1. Make a copy of det_a
                std::vector<size_t> det_a_(na);
                std::copy(det_a.begin(), det_a.end(), det_a_.begin());
                single_replace(det_a_);
                samples_list.push_back(ib * nas + bas.inv_a(det_a_)); 
            } else {
                // We will be working with beta string here
                // Just in case:
                if (nb == 0) assert(false);
                std::vector<size_t> det_b_(nb);
                std::copy(det_b.begin(), det_b.end(), det_b_.begin());
                single_replace(det_b_);
                samples_list.push_back(bas.inv_b(det_b_) * nas + ia); 
            }
        } else {
            // Do doubles; Choose from aa, ab, bb
            double r1 = u(g), r2 = u(g);
            bool aa = (r1 < p_a && r2 < p_a),
                 ab = (r1 < p_a && r2 < p_b) || (r1 < p_b && r2 < p_a),
                 bb = (r1 < p_b && r2 < p_b);
            assert (aa || ab || bb);
            if (aa) {
                std::vector<size_t> det_a_(na);
                std::copy(det_a.begin(), det_a.end(), det_a_.begin());
                double_replace(det_a_);
                samples_list.push_back(ib * nas + bas.inv_a(det_a_));
            }
            if (ab) {
                std::vector<size_t> det_a_(na);
                std::copy(det_a.begin(), det_a.end(), det_a_.begin());
                std::vector<size_t> det_b_(nb);
                std::copy(det_b.begin(), det_b.end(), det_b_.begin());
                single_replace(det_a_);
                single_replace(det_b_);
                samples_list.push_back(bas.inv_b(det_b_) * nas + bas.inv_a(det_a_));
            }
            if (bb) {
                std::vector<size_t> det_b_(nb);
                std::copy(det_b.begin(), det_b.end(), det_b_.begin());
                double_replace(det_b_);
                samples_list.push_back(bas.inv_b(det_b_) * nas + ia); 
            }
        }
    }
    return std::make_tuple(p_u, samples_list);
}
